<!doctype html><html lang=ro prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb#"><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=description content><meta name=HandheldFriendly content="True"><meta name=MobileOptimized content="320"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=keywords content="programming,
java,
tutorial,
"><meta property="og:type" content="article"><meta property="og:description" content><meta property="og:title" content="List, ArrayList, LinkedList"><meta property="og:site_name" content="Oleacă profesor"><meta property="og:image" content><meta property="og:image:type" content="image/jpeg"><meta property="og:image:width" content><meta property="og:image:height" content><meta property="og:url" content="https://babinion.xyz/note/list-arraylist-linkedlist/"><meta property="og:locale" content="ro"><meta property="article:published_time" content="2021-01-01
"><meta property="article:modified_time" content="2021-01-01
"><meta property="article:tag" content="programming"><meta property="article:tag" content="java"><meta property="article:tag" content="tutorial"><title>List, ArrayList, LinkedList</title><link rel=canonical href=https://babinion.xyz/note/list-arraylist-linkedlist/><link rel=stylesheet href=https://unpkg.com/tachyons@4.11.1/css/tachyons.min.css><link rel=stylesheet href=https://babinion.xyz/css/style.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/highlightjs@9.12.0/styles/github-gist.css><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=apple-touch-icon href=/apple-touch-icon.png></head><body lang=ro class="sans-serif w-90 w-80-m w-60-ns center mv2 mv5-ns" itemscope itemtype=http://schema.org/Article><span class=b>/</span>
<a href=https://babinion.xyz/ class="b bb bw1 pb1 no-underline black">Oleacă profesor</a>
<span class=b>/</span>
<a href=/note class="b bb bw1 pb1 no-underline black">notițe</a><section id=main class=mt5><h1 itemprop=name id=title>List, ArrayList, LinkedList</h1><span class="f6 gray">January 1, 2021</span><article itemprop=articleBody id=content class="w-90 lh-copy"><h2 id=atenție>ATENȚIE</h2><p>Informația de aici este doar ceea ce îmi imaginez eu în cap când mă gândesc la acest subiect. <strong>E posibil ca 90% din ceea ce am scris mai jos să fie greșit.</strong> Scopul acestei pagini este de a oferi o prezentare generală, foarte abstractă și pe scurt a informației.</p><h2 id=cio-za-arraylist>Cio za ArrayList?</h2><h3 id=implementarea>Implementarea</h3><p><code>List</code> - este interfața. <code>ArrayList</code> și <code>LinkedList</code> o implementează (<code>implements</code>).</p><p><code>ArrayList</code> - o listă; un tablou obișnuit; același lucru ca un vector (nu confundați cu clasa <code>Vector</code> din Java. Astea două sunt <a href="https://stackoverflow.com/questions/1386275/why-is-java-vector-and-stack-class-considered-obsolete-or-deprecated?noredirect=1&lq=1">aproape</a> aceleași, doar că listele sunt <em>unsynchronized</em>). Practic, la creare se alocă o bucată de memorie, necesară pentru un număr anumit de elemente. Dacă se adaugă mai multe elemente - o bucată încă mai mare se alocă, iar elementele din bucata precedentă (plină) sunt copiate în bucata nouă. Atunci un element este șters, elementele de după elementul șters trebuiesc recopiate. Recopierea folosește multă memorie.</p><p><code>LinkedList</code> - listă (dublu)înlănțuită. La creare nu se alocă memorie. Când se adaugă un element nou - se crează un pointer care îl leagă de elementul precedent și de cel următor. De obicei, asta va folosi mai multă memorie decât un <code>ArrayList</code>. Atunci când un element este șters, singurul lucru care se schimbă este legătura (pointerul elementului dinaintea celui șters va fi legat de cel de după cel șters).</p><h3 id=ce-și-când-folosim>Ce și când folosim?</h3><p>Folosim <code>ArrayList</code> când vrem să <strong>stocăm</strong> (salvăm, memorăm, citim și după accesăm etc.) date.</p><p>Folosim <code>LinkedList</code> când vrem să <strong>manipulăm</strong> datele (adăugăm, ștergem, modificăm). Keep in mind că această regulă nu trebuie dusă la absurd (nu folosi <code>LinkedList</code> când ai de șters 3-4 elemente, diferența va fi minimală, iar cel mai probabil un <code>ArrayList</code> va fi mai eficient).</p><h3 id=array-static-vs-lista>Array static vs Lista</h3><p>Dacă știm dinainte cât de mare va fi array-ul dinainte (capacitatea sa maximă), folosim un array static (<code>type[] a = new type[n]</code>); (cel puțin, așa ar spune regula)</p><p>Dacă nu - folosim o listă (<code>ArrayList</code>). Cu toate acestea, eu folosesc <code>ArrayList</code> în ambele cazuri, și vă recomand s-o faceți și voi. De ce?</p><h4 id=item-28-prefer-lists-to-arrays>Item 28: Prefer lists to arrays</h4><p>Conform <em>Effective Java by Joshua Bloch</em>, cod precum</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// Va esua la runtime!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Long<span style=color:#f92672>[]</span> objectArray <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Long<span style=color:#f92672>[</span>1<span style=color:#f92672>];</span>
</span></span><span style=display:flex><span>objectArray<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;I don&#39;t fit in&#34;</span><span style=color:#f92672>;</span> <span style=color:#75715e>// ArrayStoreException: tipul array-ului este Long, dar memoram un String
</span></span></span></code></pre></div><p>este considerat corect (pentru că eșuează abia la runtime). Acest cod, însă</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// Nu se va compila
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>List<span style=color:#f92672>&lt;</span>Long<span style=color:#f92672>&gt;</span> ll <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;</span>Long<span style=color:#f92672>&gt;();</span> <span style=color:#75715e>// tipuri incompatibile
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>ll<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;I don&#39;t fit in&#34;</span><span style=color:#f92672>);</span>
</span></span></code></pre></div><p>este considerat greșit. Desigur, el este greșit în ambele cazuri (nu poți pune un <code>String</code> într-un container de tip <code>Long</code>), dar cu un array afli despre asta după ce programul rulează (runtime), în timp ce cu un list - la compile time (după ce programul a fost compilat, deci înainte de a rula).</p><p>El (Joshua) menționează încă o diferență, ce ține de integrarea cu generici, dar nu o includ aici, pentru că încă nu știu prea multe despre ei. Dacă voi sunteți interesați, citiți cartea.</p><h3 id=programare--aproape--funcțională-și-clasa-stream>Programare (aproape)funcțională și clasa <code>stream</code></h3><h4 id=funcțiile-lambda>Funcțiile lambda</h4><h4 id=puțin-despre-programarea-funcțională>Puțin despre programarea funcțională</h4><p>În limbajele de programare funcțională, instrumentul de bază este (<em>ați ghicit</em>) funcția. În astfel de limbaje avem funcții care primesc funcții ca parametru, și returnează alte funcții. Java nu este un limbaj funcțional, și totuși ea (pe lângă multe alte limbaje populare astăzi) împrumută lucruri din programarea funcțională. Desigur, implementarea lor, sintaxa ș.a.m.d variază mult (sunt, până la urmă, două paradigme diferite), însă esența rămâne tot acolo (dacă îți încruntezi privirea, așa încât ochii tăi seamănă cu cei ai unui asian).</p><p>Ceea ce ne apropie de programarea funcțională este <code>stream</code>. Nu știu prea multe despre ea. Mulțumesc lui Dumnezeu că exista Intellij, care scrie 80% din cod pentru mine. Știu doar că este așa clasă sau metodă - <code>stream</code>, care face magia.</p><p>O funcție lambda e pur și simplu o funcție fără nume. Să presupunem că avem codul următor:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>sum</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> a<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> b<span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#66d9ef>return</span> a <span style=color:#f92672>+</span> b<span style=color:#f92672>;</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>afiseazaSumaDouaNumere</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>sum<span style=color:#f92672>(</span>3<span style=color:#f92672>,</span> 5<span style=color:#f92672>));</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>Desigur, nimeni treaz la cap nu scrie astfel de cod (dacă vrei să afișezi cât e 3 + 5 afișezi cât e 3 + 5), dar să ignorăm acest lucru pentru moment. Să presupunem că avem o astfel de funcție, care este folosită de o altă funcție, și numai o dată. <code>sum</code> este folosită doar de metoda <code>afiseazaSumaDouaNumere</code>, în interiorul ei, și nicăieri altundeva. Ei bine, am putea face ceva ca:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>afiseazaSumaDouaNumere</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>((</span>3<span style=color:#f92672>,</span> 5<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span><span style=color:#66d9ef>return</span> 3 <span style=color:#f92672>+</span> 5<span style=color:#f92672>;});</span> <span style=color:#75715e>// ia ca parametri doua numere oricare, returneaza suma
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>Codul de mai sus, chiar dacă nu funcționează din punct de vedere al limbajului, are sens, și exprimă ceea ce vrem să facem. Nu e nevoie să definești o funcție care face ceva simplu, și pe care oricum o vei folosi o singură dată. <strong>Programatorii, la fel ca matematicienii, sunt oameni lenoși.</strong> De ce să definești o funcție, când poți să nu o definești?</p><h4 id=iteratorii>Iteratorii</h4><p>Este destul de greu de explicat ce sunt iteratorii cu cuvinte, așa că o s-o fac prin exemple. Ceea ce trebuie să țineți minte e că fiecare iterator ia ca parametri cel puțin 2 lucruri: o funcție și o colecție (o listă), asupra căreia să aplice funcția. În Java, însă, acestea iau un singur lucru (ca parametru, în orice caz), și anume funcția. Colecția este specificată deodată, atunci când folosim metoda <code>.stream()</code> pe ea.</p><ul><li><p><code>map</code></p><p><code>map</code> ia ca parametru o funcție, pe care o aplică fiecărui element al colecției. Rezultatul iteratorului <code>map</code> este o colecție, în care fiecare element este rezultatul aplicării funcției pe elementul colecției. În exemplul de mai jos, vom crea un nou <code>ArrayList</code>, în care fiecare element este elementul respectiv din <code>numere</code> + 1.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>ArrayList<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> numere <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;(</span>List<span style=color:#f92672>.</span><span style=color:#a6e22e>of</span><span style=color:#f92672>(</span>1<span style=color:#f92672>,</span>2<span style=color:#f92672>,</span>5<span style=color:#f92672>,</span>9<span style=color:#f92672>,</span>11<span style=color:#f92672>,</span>4<span style=color:#f92672>,</span>7<span style=color:#f92672>,</span>2<span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ArrayList<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> numereNou <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>ArrayList<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;)</span> numere<span style=color:#f92672>.</span><span style=color:#a6e22e>stream</span><span style=color:#f92672>().</span><span style=color:#a6e22e>map</span><span style=color:#f92672>(</span>element <span style=color:#f92672>-&gt;</span> element <span style=color:#f92672>=</span> element <span style=color:#f92672>+</span> 1<span style=color:#f92672>).</span><span style=color:#a6e22e>collect</span><span style=color:#f92672>(</span>Collectors<span style=color:#f92672>.</span><span style=color:#a6e22e>toList</span><span style=color:#f92672>());</span>
</span></span></code></pre></div><p>Destul de greu de citit, nu-i așa? De asta, vă recomand ca atunci când folosiți cel puțin două metode ca <code>.numeMetoda()</code> în stream-ul vostru, să le separați pe linii.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>ArrayList<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> numereNou <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>(</span>ArrayList<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;)</span> numere<span style=color:#f92672>.</span><span style=color:#a6e22e>stream</span><span style=color:#f92672>()</span>           <span style=color:#75715e>// (1)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#f92672>.</span><span style=color:#a6e22e>map</span><span style=color:#f92672>(</span>element <span style=color:#f92672>-&gt;</span> element <span style=color:#f92672>=</span> element <span style=color:#f92672>+</span> 1<span style=color:#f92672>)</span> <span style=color:#75715e>// (2)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#f92672>.</span><span style=color:#a6e22e>collect</span><span style=color:#f92672>(</span>Collectors<span style=color:#f92672>.</span><span style=color:#a6e22e>toList</span><span style=color:#f92672>());</span>         <span style=color:#75715e>// (3)
</span></span></span></code></pre></div><p>Și acum, hai să analizăm pe linii.</p><ol><li><code>(ArrayList&lt;Integer>)</code> - asta se numește <em>cast</em>, și reprezintă o transformare, dintr-un tip în altul. E nevoie să <em>cast</em>-uim, pentru că în linia 3, metoda <code>.collect(Collectors.toList())</code> nu specifica tipul listei.
<code>numere.stream()</code> - sintaxa de folosire. Asta e ceea ce transformă obiectul nostru într-un obiect ciotkii 😎.</li><li><code>.map(element -> element = element + 1)</code> - Apelul funcției <code>.map()</code> cu o lambda, care ia un argument și îi adaugă 1. Această funcție va crea o listă nouă, în care fiecare element este elemenmtul din lista <code>numere</code> + 1. O să accentuez faptul că <code>.map(...)</code> <strong>nu modifică lista numere, ci creează o listă nouă</strong>.</li><li><code>.collect(Collectors.toList())</code> - ceea ce transformă rezultatul aplicării <code>map</code>-ului într-o listă. Nu știu prea bine cum funcționează, dar presupun că <code>map</code> nu crează obiectul propriu-zis, ci îl păstrează în memorie, iar <code>.collect()</code> îl ia din memorie și îl transformă în valoare.</li></ol></li></ul></article><span class="f6 gray mv3" title="Lastmod: January 1, 2021. Published at: 2021-01-01."></span><footer><div><p class="f6 gray mt6 lh-copy">© 2020-2050 <a href=https://github.com/owhyy/website-hugo>Babin Ion</a>.</p></div></footer><script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/highlight.min.js></script>
<script>hljs.initHighlightingOnLoad()</script></body></html>